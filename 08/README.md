 ## состав директории

 - `weakref_slots.py` - определены свои типы, которые далее импортируются
 - `weakref_slots_time.py` - измеряются времена создания большого количества экземпляров и изменения атрибутов
 - `weakref_slots_memory.py` - профилирование памяти
 - `weakref_slots_profile.py` - профилирование вызовов
 - `profile_deco.py` - декоратор для профилирования
 - `time_creating.PNG`

 Экземпляры классов с обычными атрибутами создаются медленнее всех. Вероятно, это связано с расходами на создание словаря.

 Экземпляры классов с `weakref` создаются быстрее, чем экземпляры классов с обычными атрибутами. Предполагаю, что это может быть связано с пока незнакомыми мне механизмами управления ссылками.
 
 Экземпляры классов со `__slots__` создаются быстрее всех. Это может быть связано с тем, что для хранения атрибутов не используется словарь.
 
 - `time_changing.PNG`

 Изменение атрибутов у всех происходит за сопоставимое время, но `__slots__` всё же немного быстрее. Словарь не создаётся --> доступ к атрибутам происходит быстрее.

 - `memory_10_000.PNG`
 - `memory_100_000.PNG`
 - `memory_1_000_000.PNG`

 Чем большее количество экземпляров создаётся, тем более ощутима экономия памяти с помощью `__slots__`. Наверное, потому что атрибуты хранятся не в словаре. `__weakref__` при создании экземпляров используют ещё меньше памяти, чем `__slots__`. Предполагаю, что это может быть связано с пока незнакомыми мне механизмами управления ссылками.

 При изменении атрибутов обычные классы и классы с `weakref` расходуют сопоставимое количество памяти. Классы со `__slots__` используют меньше памяти.

 - `calls_terminal.PNG`
 - `calls_code.PNG`

 `tottime` при создании большого количества экземпляров и изменении их атрибутов наименьшее у `weakref`, наибольшее у классов с обычными атрибутами, у `__slots__` посередине. Честно говоря, для меня не совсем очевидно такое поведение. Кажется, что `__weakref__` наоборот, должны влечь за собой дополнительные сложности при управлении ссылками.
